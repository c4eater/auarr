#!/bin/bash


check_mixed_locales()
# Returns "solid" when the input string has no words with both Latin and Cyrillic chars, "mixed" otherwise. Used in detectenc().
{
    if [ ! "${1}" ]; then return $EMPTY_ARG; fi
    
    local _words
    local _cyr_letters_count
    local i
    _words="$(echo "${1}" | egrep -o -e '\<[ЁёA-Za-zА-Яа-я]{1,}\>' 2>/dev/null)"

    for i in $_words; do
        _cyr_letters_count="$(echo "${i}" | grep -o -e '[А-Яа-я]' 2>/dev/null | sed -n -e '$=')"
        if [ -z "${_cyr_letters_count}" ]; then _cyr_letters_count=0; fi
        if [ ${_cyr_letters_count} -gt 0 ] && [ ${_cyr_letters_count} -lt ${#i} ]; then echo "mixed"; return; fi
    done

	echo "solid"
}


check_inverted_case()
# Returns 0 when the input string has no words like aBCDEF, 1 otherwise. Used in detectenc().
{
    if [ ! "${1}" ]; then return $EMPTY_ARG; fi
    echo "${1}" | egrep -o -m 1 -e '\<[а-яa-z][А-ЯA-Z]{2,}\>' --silent 2>/dev/null
}




resolve()
# Resolves the string containing a relative file/directory address (special chars must be unescaped) into an absolute address.
# Exit codes: 0 = success, 1 = error, 2 = empty arg
{
    if [ "${1}" = "" ]; then ERRMSG="Empty argument"; return 2; fi

    local path="$(echo -e "$1" |  sed -r -e 's/[][\&\;\(\)\!\"\*\+\?\`,.:<=>#№{}$%@ ]/\\&/g')" # Escaping special chars
    local basedir="$(dirname "$path")"
    local filename="$(basename "$1")"

    basedir="$(eval "cd "${basedir}" &>/dev/null && pwd")"

    local abspath="$(echo "$basedir/$filename" | sed -e 's/\/\//\//g')"
    

    if [ "${basedir}" = "" ]; then
        ERRMSG="Cannot change to base directory $(dirname "$path")."
        return 1
    elif [ -e "${abspath}" ]; then
        ERRMSG=""
        echo "${abspath}"
        return 0
    else
        ERRMSG="${abspath} does not exist."
        echo
        return 1
    fi
    return 0
}


detectenc()
# Returns the argument encoding, focusing on cyrillic codepages (CP1251, CP866, KOI8-R). Returns "???" when failed.
# Calls enca, then an additional hand-made script in case of enca fail.
# Exit codes: 0 = success, 1 = error, 2 = empty arg
{
    local ans="UTF-8"
    local input="$(echo "${1}" | sed -r -e 's/\r$//')"


    if [ -z "${1}" ]; then
        ERRMSG="Empty argument"
        return 2
    else
        ans="$(echo "${1}" | enca -i -L ru)"

        if [ "${ans}" = "???" ]; then
#           Enca failed to detect encoding. Launching hand-made encoding detection
#           Maybe it's UTF-8
            input="$(echo "${1}" | sed -r -e 's/\r$//')"
            checked="$(getprintable "${input}")"
            if [ ${#checked} -eq ${#input} ]; then
                        ans="UTF-8"
            fi
        fi


        if [ "${ans}" = "???" ]; then
#           Maybe it's ISO-8859-1
            input="$(echo "${1}" | iconv -f ISO-8859-1 -t UTF-8 | sed -re 's/\r$//')"
            checked="$(getprintable "${input}")"
			result=$(check_mixed_locales "${input}")
			echo "Test: $result"

            if [ ${#checked} -eq ${#input} ] && [ $(check_mixed_locales "${input}") == "0" ]; then
                ans="ISO-8859-1"
            fi
        fi


        if [ "${ans}" = "???" ]; then
#           Maybe it's CP1251
            input="$(echo "${1}" | iconv -f CP1251 -t UTF-8 | sed -r -e 's/\r$//')"
            checked="$(getprintable "${input}")"
            
            if [ ${#checked} -eq ${#input} ] && [ $(check_mixed_locales "${input}") -eq "0" ] && [ $(check_inverted_case "${input}") -eq "0" ]; then
                ans="CP1251"
            fi
        fi

        if [ "${ans}" = "???" ]; then
#           Maybe it's CP866
            input="$(echo "${1}" | iconv -f CP866 -t UTF-8 | sed -r -ep 's/\r$//')"
            checked="$(getprintable "${input}")"

            if [ ${#checked} -eq ${#input} ] && [ $(check_mixed_locales "${input}") -eq "0" ] && [ $(check_inverted_case "${input}") -eq "0" ]; then
                ans="CP866"
            fi
        fi


        if [ "${ans}" = "???" ]; then
#           Maybe it's KOI8-R
            input="$(echo "${1}" | iconv -f KOI8-R -t UTF-8 | sed -r -e 's/\r$//')"
            checked="$(getprintable "${input}")"

            if [ ${#checked} -eq ${#input} ] && [ $(check_mixed_locales "${input}") -eq "0" ] && [ $(check_inverted_case "${input}") -eq "0" ]; then
                ans="KOI8-R"
            fi
        fi

        if [ "${ans}" = "???" ]; then
#           Maybe it's ISO-8859-1 with diacritic chars
            input="$(echo "${1}" | iconv -f ISO-8859-1 -t UTF-8 | sed -re 's/\r$//')"
            checked="$(getprintable-nonstrict "${input}")"

echo "${input}">input1
echo "${checked}">input2
            if [ ${#checked} -eq ${#input} ] && [ $(check_mixed_locales "${input}") -eq "0" ] && [ $(check_inverted_case "${input}") -eq "0" ]; then
                ans="ISO-8859-1"
            fi
        fi


    fi
    echo "${ans}"
}



getprintable()
# Returns the concatenation of "printable" symbols in the input string.
{
    local ans=""

    ans="$(echo "${1}" | sed -e 's/$/_NEWLINE/g' |  grep -o -e '[[:print:]]*' | tr -d "\n" | sed -e 's/_NEWLINE/\n/g')"
    echo "${ans}"
}


getprintable-nonstrict()
# Same, but allows Latin chars with diacritics
{
    local ans=""

    ans="$(echo "${1}" | sed -e 's/$/_NEWLINE/g' |  grep -o -e '[-!\"#№{}$%&\()*+,.:;<=>?@_\`\/~ЁёA-Za-zА-Яа-я0-9[:blank:]]*' | tr -d "\n" | sed -e 's/_NEWLINE/\n/g')"
    echo "${ans}"
}


fixchars()
# Replaces the "prohibited" symbols \/:*?"<>| in the input string with dashes. Required for correct filename/dirname generation.
{
    echo "${1}" | sed -e 's/["/\*?:<>|]/-/g'
}






EMPTY_ARG=5

detectenc "$(cat "${1}")"


#check_mixed_locales "$(cat "${1}")"; echo "$?"

# Neither of INDIR and OUTDIR must be a subfolder of another one in the pair!
